# Мотивация выбора баз данных и механик коммуникаций 

## ADR 1 — Выбор базы данных и способ хранения фото: PostgreSQL

Дата: 28.11.2025

> **Контекст:** Система включает работу с пользователями, задачами, проектами и  мультимедиаданными (в частности — фотографиями пользователей и вложениями к задачам). Необходимо выбрать тип основной базы данных, а также определить подход для хранения бинарных медиафайлов (фото). Система должна поддерживать строгую консистентность данных,транзакции, сложные связи между сущностями, хранение фото в формате BLOB.

>**Решение:** Мы выбираем PostgreSQL как основную реляционную базу данных.
Дополнительно принимается решение хранить фотографии напрямую в базе данных как BYTEA (BLOB). 

Аргументами в поддержку данной технологии являются:
* PostgreSQL обеспечивает ACID-транзакции и широкие возможности по моделированию данных.

* Команда знакома с PostgreSQL, что снижает риски и ускоряет разработку.

* Поддержка BYTEA позволяет безопасно хранить бинарные данные без внедрения сторонних решений (S3/MinIO).

* Упрощается резервное копирование — данные и медиа в одной БД.

* Уменьшается число внешних зависимостей.
 

> **Последствия:** 

Плюсы:

* Простота архитектуры — все данные хранятся в единой системе.

* Нет необходимости развертывать отдельный файловый сторедж.

* Прямая транзакционная согласованность между объектами и их фотографиями.

Минусы:

* Рост размера базы данных — потенциальные проблемы с производительностью при большом количестве фото.

* Резервные копии БД могут занимать существенно больше места.

В будущем есть возможность вынести хранение фото в объектный сторедж в будущем и мигрировать схему.

## ADR 2 — Механизм коммуникации между клиентом и сервером: RESTAPI

Дата: 28.11.2025

> **Контекст:** Система подразумевает обмен данными между клиентским приложением и сервером. Основными требованиями является простая коммуникация клиент–сервер, поддержка уведомлений в реальном времени, минимальное количество дополнительных инфраструктурных сервисов, возможность масштабирования позже.

>**Решение:** Использовать REST API для CRUD-операций. 

> **Последствия:** 

Плюсы:

* Уменьшение сложности инфраструктуры.

* Быстрая разработка и лёгкая поддержка.

* Отсутствие накладных расходов на установку и обслуживание брокеров сообщений.

Минусы:

* Если система вырастет в распределённую архитектуру, возможно потребуется вернуться к идее message broker.

## ADR 3 — Выбор backend-фреймворка: Spring Boot

Дата: 28.11.2025

> **Контекст:** Backend должен обеспечивать работу API, безопасность, обработку файлов. Изначально рассматривался Ktor, но было решено изменить выбор из-за требований к зрелости фреймворка и наличию готовых решений.

>**Решение:** Использовать Spring Boot как основной backend-фреймворк.
Основными аргументами выбора данной технологии являются:
* Большой набор встроенных модулей (Spring Web, Spring Security, Data JPA, WebSocket).

* Богатая экосистема и документация.

* Легкая интеграция с PostgreSQL.

* Более высокая продуктивность для команды благодаря известности Spring.

* Упрощённая конфигурация и быстрый запуск через auto-configuration.


> **Последствия:** 

Плюсы:

* Быстрый старт разработки.

* Меньше "боилерплейта", чем в Ktor.

* Легкое внедрение безопасности, CORS, OAuth2, загрузки файлов и т.п.

* Устойчивость для производства.

Минусы:

* Spring тяжелее и более ресурсоёмкий, чем Ktor.

* Приложение запускается медленнее, чем на Ktor.

В будущем есть возможность выделить более лёгкую версию сервиса, если потребуется.

## ADR 4 — Выбор технологии для ML-модулей: Python FastAPI

Дата: 28.11.2025

> **Контекст:** ML сервисы требуют использование PyTorch, notebook-workflow, экспорта моделей, быстрого прототипирования.

>**Решение:** Использовать Python + FastAPI для сервисов: NLP (Transformers), CV (PyTorch), Pricing Model, SHAP.

> **Последствия:** 

Плюсы:

* ML разработчики работают в привычной экосистеме.

* FastAPI быстрый и удобный.

* Лёгкая интеграция с PyTorch/Sklearn.

Минусы:

* требуется поддерживать несколько сред (Kotlin + Python).

* DevOps становится сложнее.

## ADR 5 — Выбор коммуникации клиента с backend: HTTPS JSON API

Дата: 28.11.2025

> **Контекст:** Клиентская часть системы представлена двумя основными типами приложений: веб-клиентом (JavaScript) и мобильными приложениями (Kotlin), которые должны одинаково взаимодействовать с сервером независимо от платформы, окружения выполнения и особенностей сетевого стека. Все эти клиенты должны иметь доступ к единообразному, предсказуемому, хорошо документированному и стабильному интерфейсу, который позволит минимизировать дублирование логики, упростить интеграцию, обеспечить совместимость между версиями и гарантировать консистентность данных. Также важно, чтобы механизм обмена данными был простым в отладке, широко поддерживался инструментами и не требовал специализированных библиотек на стороне клиента.

>**Решение:** Мы принимаем решение использовать взаимодействие через HTTPS JSON REST API, поскольку этот подход обеспечивает единый стандарт передачи данных между клиентами и backend-сервисом, основанный на надёжной и хорошо известной модели запрос–ответ. Формат JSON является простым, гибким, человекочитаемым и эффективно поддерживается большинством платформ и языков. Использование HTTPS гарантирует защищённый канал связи, что важно для передачи персональных данных и аутентификационных токенов. REST-ориентированная архитектура обеспечивает предсказуемость эндпоинтов, слабую связанность и возможность естественного расширения API в будущем, а также позволяет автоматически генерировать документацию через OpenAPI/Swagger, поддерживать SDK и создавать стабильную интеграционную среду для всех типов клиентов.

> **Последствия:** Выбранный подход приносит ряд значимых преимуществ: унифицированный формат взаимодействия для веб- и мобильных клиентов упрощает разработку, сопровождение и тестирование; JSON-данные легко сериализуются и десериализуются; REST-эндпоинты хорошо структурируются и документируются, а наличие OpenAPI-спеки делает API прозрачным и удобным для автоматизации. Вместе с тем, использование JSON API не является оптимальным выбором для задач, требующих обмена данными в реальном времени, поскольку REST не предполагает постоянного поддержания соединения или стриминга событий. Однако на данном этапе разработки real-time-коммуникация не является необходимостью, поэтому ограничения этого подхода не оказывают существенного влияния на архитектуру системы.

## ADR 7 — Выбор механизма кеширования: Redis

Дата: 28.11.2025

> **Контекст:** В системе требуется обеспечить высокую скорость отклика для операций, связанных с обработкой часто повторяющихся данных, которые нецелесообразно постоянно рассчитывать или извлекать из основной базы данных. В частности, речь идёт о кешировании геоданных (например, обратного геокодирования и координатных преобразований), сохранении промежуточных вычислительных признаков для моделей или аналитики (feature caching), а также реализации rate-limiting для защиты API от избыточных запросов. Эти операции должны выполняться с минимальной задержкой, поддерживать механизм протухания (TTL), работать с различными структурами данных и масштабироваться горизонтально без сложных настроек.

>**Решение:** Мы выбираем Redis как основной механизм кеширования, поскольку он представляет собой высокопроизводительное in-memory хранилище, обеспечивающее быстрый доступ к данным, поддержку TTL на уровне ключей, широкие встроенные структуры (строки, хэши, множества, списки, sorted sets), а также готовые механизмы для реализации rate-limiting и atomic counters. Redis легко интегрируется с большинством серверных фреймворков и может работать в разных режимах (single node, replica set, cluster), что делает его удобным для текущих задач и будущего масштабирования системы. Использование Redis позволяет вынести быстрые и кратковременные операции за пределы основной PostgreSQL-базы, разгружая её и повышая общую производительность приложения.

> **Последствия:** Плюсы включают минимальные задержки при чтении и записи благодаря размещению данных в оперативной памяти, гибкое TTL-кеширование, которое позволяет автоматически очищать устаревшие данные, а также богатый набор встроенных структур данных, благодаря которым можно эффективно хранить ключевые типы информации — от простых значений до сложных агрегатов и счетчиков. Минусы связаны с тем, что Redis остаётся volatile-хранилищем: данные могут быть потеряны при отказе сервера, поэтому важные ключи требуют дополнительного резервирования, настройки персистентности (AOF/RDB) или использования кластерной конфигурации. Также необходимо мониторинг состояния памяти, поскольку объём RAM ограничен и может стать узким местом при больших объёмах данных.

## ADR 8 — Формат отчётов: PDF (ReportLab)

Дата: 28.11.2025

> **Контекст:** В рамках проектной документации и функционала системы требуется генерация отчётов, которые должны быть легко читаемыми пользователями, независимо от их устройства или операционной системы, а также должны быть доступны в режиме офлайн и сохранять неизменность содержания после генерации. Формат отчётов должен гарантировать отсутствие зависимости от браузера, стабильность отображения структуры и поддержку сложных элементов, таких как таблицы, графики и изображения. Кроме того, важным аспектом является возможность автоматической генерации подобных документов на сервере без необходимости использования сторонних онлайн-сервисов или ручной верстки.

>**Решение:** Принято решение использовать формат PDF, генерируемый с помощью библиотеки ReportLab, поскольку он предоставляет низкоуровневый, но при этом гибкий и мощный инструмент для создания документально строгих и визуально структурированных отчётов. ReportLab позволяет программно формировать любой тип контента — текстовые блоки, заголовки, таблицы, диаграммы, изображения и кастомную векторную графику — при этом полностью контролируя компоновку элементов на странице. Такой подход даёт возможность создавать отчёты одинакового качества на любых серверах и в любых окружениях, гарантируя детерминированный итоговый результат и удобную интеграцию с backend-приложением.

> **Последствия:** Использование PDF и ReportLab даёт значительные преимущества. ReportLab предоставляет глубокий контроль над визуальной частью отчётов и позволяет создавать сложные визуализации, графики и диаграммы непосредственно в процессе генерации. Вместе с тем существует и недостаток: процесс разработки PDF-шаблонов с помощью ReportLab требует больше времени и усилий по сравнению с HTML-версткой, поскольку основан на программной генерации разметки и требует точного контроля координат и структуры страниц. Это может потребовать более высокой квалификации разработчика и усложнить внесение изменений в дизайн отчётов.

## ADR 9 — Хранение ML-моделей в виде артефактов (PostgreSQL)

Дата: 28.11.2025

> **Контекст:** В системе используются несколько типов моделей машинного обучения — включая NLP-модели, модели компьютерного зрения и модели прогнозирования цен — каждая из которых развивается независимыми циклами и обновляется по мере появления новых данных или улучшения алгоритмов. Для корректной эксплуатации таких моделей необходимо иметь возможность хранить полную историю версий, включая необработанные артефакты, дату обучения, оценочные метрики и параметры, чтобы разработчики могли быстро возвращаться к прошлым состояниям, анализировать различия между релизами и реплицировать результаты экспериментов. Кроме того, инфраструктура должна позволять распространять обновлённые модели без необходимости пересборки или повторного развёртывания серверного приложения, чтобы минимизировать простой и сохранять гибкость в ML-процессе.

>**Решение:** Для обеспечения прозрачного управления моделями предлагается хранить сами бинарные артефакты моделей (например, .pt, .onnx, .pickle) непосредственно в PostgreSQL в виде BLOB-полей (BYTEA), а все сопутствующие метаданные, такие как версия, дата обучения, параметры обучения, качество на тестовых выборках и служебные отметки, сохранять в отдельных структурированных колонках в той же базе. Такой подход позволяет единообразно управлять как моделью, так и информацией о ней, используя транзакционную природу PostgreSQL, обеспечивая атомарность обновлений и простоту интеграции с существующей системой версионирования данных, логированием и аудитом. Благодаря централизованному хранению сервер ML-сервиса может в реальном времени подтягивать актуальную версию модели без необходимости ручных операций и без зависимости от внешних файловых хранилищ или распределённых сторедж-систем.

> **Последствия:** Такой подход обеспечивает полный контроль над жизненным циклом моделей: можно легко откатываться на любую предыдущую версию, просматривать весь набор исторических метрик, анализировать влияние изменений и проводить A/B-тестирование без нарушения стабильности основного сервиса. Хранение артефактов в базе также упрощает деплой — обновление модели превращается в транзакционную запись в PostgreSQL, без пересборки контейнеров или обновлений инфраструктуры. Однако это решение накладывает дополнительные обязательства: необходимо обеспечить мониторинг совместимости версий моделей с серверной логикой, поскольку новые артефакты могут нарушить согласованность с используемым кодом; кроме того, подобный подход увеличивает нагрузку на хранилище и требует продуманной политики очистки и резервного копирования для избежания избыточного роста базы данных.






